#!/usr/bin/env python3
"""
Run window-search axis training, QC, and evoked flow for ALL sessions.

This script:
1. Discovers all sessions in out/stim/
2. Trains axes with window search (--searchC for stim, --searchS for sacc)
3. Runs QC for each session
4. Runs evoked flow analysis

Supports parallel execution on Mac using multiprocessing.

Usage:
    # Dry run (see what would be executed)
    python cli/run_all_sessions_winsearch.py --dry_run

    # Run with 4 parallel workers
    python cli/run_all_sessions_winsearch.py --workers 4

    # Run specific sessions only
    python cli/run_all_sessions_winsearch.py --sessions 20231109 20231121

    # Skip training (use existing axes)
    python cli/run_all_sessions_winsearch.py --skip_train

    # Skip flow (only train and QC)
    python cli/run_all_sessions_winsearch.py --skip_flow
"""

from __future__ import annotations
import argparse
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional
from concurrent.futures import ProcessPoolExecutor, as_completed
import time

PROJECT_ROOT = Path(__file__).resolve().parents[1]

# CLI scripts
CLI_TRAIN = "cli/train_axes.py"
CLI_QC = "cli/qc_axes.py"
CLI_EVOKED = "cli/run_one_session_evoked.py"


def discover_sessions(out_root: Path, align: str = "stim") -> List[str]:
    """Discover all session IDs that have caches."""
    sessions = []
    align_dir = out_root / align
    if not align_dir.exists():
        return sessions
    
    for sid_dir in sorted(align_dir.iterdir()):
        if sid_dir.is_dir() and (sid_dir / "caches").is_dir():
            # Check it's a valid session ID (starts with 20)
            if sid_dir.name.startswith("20"):
                sessions.append(sid_dir.name)
    
    return sessions


def run_cmd(cmd: List[str], dry: bool = False) -> int:
    """Run a command, return exit code."""
    print(f"[RUN] {' '.join(cmd)}")
    if dry:
        return 0
    
    env = os.environ.copy()
    env["PYTHONPATH"] = str(PROJECT_ROOT) + (f":{env['PYTHONPATH']}" if env.get("PYTHONPATH") else "")
    
    try:
        result = subprocess.run(cmd, check=True, env=env, capture_output=False)
        return result.returncode
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] Command failed with exit {e.returncode}")
        return e.returncode


def process_session(
    sid: str,
    out_root: Path,
    python: str,
    axes_tag_base: str = "winsearch",
    orientation: str = "vertical",
    stim_feature: str = "C",
    sacc_feature: str = "S",
    skip_train: bool = False,
    skip_qc: bool = False,
    skip_flow: bool = False,
    dry: bool = False,
    search_len_ms: List[float] = None,
) -> dict:
    """Process a single session: train, QC, flow."""
    
    start_time = time.time()
    results = {"sid": sid, "train": None, "qc_stim": None, "qc_sacc": None, "flow": None, "error": None}
    
    if search_len_ms is None:
        search_len_ms = [50, 100, 150, 200, 250]
    
    try:
        # === TRAINING ===
        if not skip_train:
            # Train stim axes with window search for C
            if stim_feature != "none" and (out_root / "stim" / sid / "caches").exists():
                train_cmd = [
                    python, CLI_TRAIN,
                    "--out_root", str(out_root),
                    "--align", "stim",
                    "--sid", sid,
                    "--features", stim_feature,
                    "--orientation", orientation,
                    "--searchC",
                    "--search_len_ms", *[str(l) for l in search_len_ms],
                ]
                rc = run_cmd(train_cmd, dry=dry)
                results["train"] = "ok" if rc == 0 else f"fail:{rc}"
                if rc != 0:
                    results["error"] = f"train_stim failed"
                    return results
            
            # Train sacc axes with window search for S
            if sacc_feature != "none" and (out_root / "sacc" / sid / "caches").exists():
                train_cmd = [
                    python, CLI_TRAIN,
                    "--out_root", str(out_root),
                    "--align", "sacc",
                    "--sid", sid,
                    "--features", sacc_feature,
                    "--orientation", orientation,
                    "--searchS",
                    "--search_len_ms", *[str(l) for l in search_len_ms],
                ]
                rc = run_cmd(train_cmd, dry=dry)
                if rc != 0:
                    results["error"] = f"train_sacc failed"
        
        # === QC ===
        if not skip_qc:
            # Determine the tag (auto-generated by train_axes.py)
            stim_tag = f"winsearch-stim-{orientation}"
            sacc_tag = f"winsearch-sacc-{orientation}"
            
            # QC stim
            if stim_feature != "none" and (out_root / "stim" / sid / "axes" / stim_tag).exists():
                qc_cmd = [
                    python, CLI_QC,
                    "--out_root", str(out_root),
                    "--align", "stim",
                    "--sid", sid,
                    "--tag", stim_tag,
                    "--orientation", orientation,
                ]
                rc = run_cmd(qc_cmd, dry=dry)
                results["qc_stim"] = "ok" if rc == 0 else f"fail:{rc}"
            
            # QC sacc
            if sacc_feature != "none" and (out_root / "sacc" / sid / "axes" / sacc_tag).exists():
                qc_cmd = [
                    python, CLI_QC,
                    "--out_root", str(out_root),
                    "--align", "sacc",
                    "--sid", sid,
                    "--tag", sacc_tag,
                    "--orientation", orientation,
                ]
                rc = run_cmd(qc_cmd, dry=dry)
                results["qc_sacc"] = "ok" if rc == 0 else f"fail:{rc}"
        
        # === FLOW ===
        if not skip_flow:
            flow_cmd = [
                python, CLI_EVOKED,
                "--out_root", str(out_root),
                "--sid", sid,
                "--axes_tag_base", axes_tag_base,
                "--stim_feature", stim_feature,
                "--sacc_feature", sacc_feature,
                "--orientation", orientation,
            ]
            rc = run_cmd(flow_cmd, dry=dry)
            results["flow"] = "ok" if rc == 0 else f"fail:{rc}"
        
        results["time_sec"] = time.time() - start_time
        
    except Exception as e:
        results["error"] = str(e)
    
    return results


def main():
    ap = argparse.ArgumentParser(
        description="Run window-search training, QC, and flow for all sessions."
    )
    ap.add_argument("--out_root", default="out",
                    help="Root directory (default: out)")
    ap.add_argument("--sessions", nargs="*", default=None,
                    help="Specific sessions to run (default: all discovered)")
    ap.add_argument("--workers", type=int, default=1,
                    help="Number of parallel workers (default: 1, sequential)")
    ap.add_argument("--axes_tag_base", default="winsearch",
                    help="Base tag for axes (default: winsearch)")
    ap.add_argument("--orientation", default="vertical",
                    choices=["vertical", "horizontal", "pooled"],
                    help="Orientation for training and flow (default: vertical)")
    ap.add_argument("--stim_feature", default="C",
                    choices=["C", "R", "T", "O", "none"],
                    help="Feature for stim alignment (default: C)")
    ap.add_argument("--sacc_feature", default="S",
                    choices=["S", "C", "T", "O", "none"],
                    help="Feature for sacc alignment (default: S)")
    ap.add_argument("--search_len_ms", nargs="+", type=float, 
                    default=[50, 100, 150, 200, 250],
                    help="Window lengths to search (default: 50 100 150 200 250)")
    ap.add_argument("--skip_train", action="store_true",
                    help="Skip training (use existing axes)")
    ap.add_argument("--skip_qc", action="store_true",
                    help="Skip QC")
    ap.add_argument("--skip_flow", action="store_true",
                    help="Skip flow analysis")
    ap.add_argument("--python", default=sys.executable,
                    help="Python interpreter (default: current)")
    ap.add_argument("--dry_run", action="store_true",
                    help="Print commands only, don't execute")
    
    args = ap.parse_args()
    
    out_root = Path(args.out_root)
    
    # Discover or use specified sessions
    if args.sessions:
        sessions = args.sessions
    else:
        sessions = discover_sessions(out_root, "stim")
    
    if not sessions:
        print("[ERROR] No sessions found!")
        return 1
    
    print(f"=" * 60)
    print(f"Window Search Pipeline: {len(sessions)} sessions")
    print(f"=" * 60)
    print(f"  out_root: {out_root}")
    print(f"  axes_tag_base: {args.axes_tag_base}")
    print(f"  orientation: {args.orientation}")
    print(f"  stim_feature: {args.stim_feature}")
    print(f"  sacc_feature: {args.sacc_feature}")
    print(f"  search_len_ms: {args.search_len_ms}")
    print(f"  workers: {args.workers}")
    print(f"  skip_train: {args.skip_train}")
    print(f"  skip_qc: {args.skip_qc}")
    print(f"  skip_flow: {args.skip_flow}")
    print(f"  dry_run: {args.dry_run}")
    print(f"")
    print(f"Sessions: {', '.join(sessions)}")
    print(f"=" * 60)
    
    start_time = time.time()
    all_results = []
    
    if args.workers <= 1:
        # Sequential execution
        for i, sid in enumerate(sessions):
            print(f"\n[{i+1}/{len(sessions)}] Processing {sid}...")
            result = process_session(
                sid=sid,
                out_root=out_root,
                python=args.python,
                axes_tag_base=args.axes_tag_base,
                orientation=args.orientation,
                stim_feature=args.stim_feature,
                sacc_feature=args.sacc_feature,
                skip_train=args.skip_train,
                skip_qc=args.skip_qc,
                skip_flow=args.skip_flow,
                dry=args.dry_run,
                search_len_ms=args.search_len_ms,
            )
            all_results.append(result)
            print(f"    â†’ {result}")
    else:
        # Parallel execution
        print(f"\n[parallel] Using {args.workers} workers...")
        with ProcessPoolExecutor(max_workers=args.workers) as executor:
            futures = {
                executor.submit(
                    process_session,
                    sid=sid,
                    out_root=out_root,
                    python=args.python,
                    axes_tag_base=args.axes_tag_base,
                    orientation=args.orientation,
                    stim_feature=args.stim_feature,
                    sacc_feature=args.sacc_feature,
                    skip_train=args.skip_train,
                    skip_qc=args.skip_qc,
                    skip_flow=args.skip_flow,
                    dry=args.dry_run,
                    search_len_ms=args.search_len_ms,
                ): sid for sid in sessions
            }
            
            for future in as_completed(futures):
                sid = futures[future]
                try:
                    result = future.result()
                    all_results.append(result)
                    print(f"[done] {sid}: {result}")
                except Exception as e:
                    print(f"[ERROR] {sid}: {e}")
                    all_results.append({"sid": sid, "error": str(e)})
    
    # Summary
    total_time = time.time() - start_time
    print(f"\n" + "=" * 60)
    print(f"SUMMARY")
    print(f"=" * 60)
    print(f"Total time: {total_time:.1f}s ({total_time/60:.1f}min)")
    print(f"Sessions processed: {len(all_results)}")
    
    errors = [r for r in all_results if r.get("error")]
    if errors:
        print(f"\nErrors ({len(errors)}):")
        for r in errors:
            print(f"  {r['sid']}: {r['error']}")
    else:
        print(f"\nAll sessions completed successfully!")
    
    return 0 if not errors else 1


if __name__ == "__main__":
    sys.exit(main())

